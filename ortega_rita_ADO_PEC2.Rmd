---
title: "PEC2 Análisis de Datos Ómicos"
author: "Rita Ortega Vallbona"
date: '`r format(Sys.Date(),"%e de %B, %Y")`'
output: 
  pdf_document: 
    df_print: kable
    fig_caption: yes
    keep_tex: yes
    number_sections: yes
    toc: yes
    toc_depth: 3
  html_document: 
    number_sections: yes
    theme: united
    toc: yes
    toc_float: yes
lang: en # language,  en: english (default), es: español, ...
params:
  file1: targets.csv
  file2: counts.csv
  folder.data: data
  seed.extract: 555
bibliography: bibliografiaPEC2ADO.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE,
                      comment = NA, prompt = TRUE, tidy = TRUE,
                      tidy.opts=list(width.cutoff=60),
                      fig.width = 7, 
                      fig.height = 7, fig_caption = TRUE, 
                      cache=TRUE)
```

```{r libraries, include=FALSE}
# Función instalar paquetes
usePackage <- function(paq) {    
    if (!is.element(paq, installed.packages()[,1]))
        install.packages(paq, dep = TRUE)
    require(paq, character.only = TRUE)
}

usePackage("knitr")
usePackage("ggplot2")

if(!require(locfit)) install.packages("locfit", type = "source")

if(!require(kableExtra)) install.packages('kableExtra',  repos = 'http://cran.rstudio.com')

if(!require(printr)) install.packages('printr', type = 'source',repos = c('http://yihui.name/xran','http://cran.rstudio.com'))

if(!require(ggrepel)) install.packages('ggrepel', repos = 'http://cran.rstudio.com')
```

```{r Bioconductor, include=FALSE}
if(!requireNamespace("BiocManager", quietly = TRUE)) 
BiocManager::install()

#Paquetes de Bioconductor necesarios para el análisis:

BiocManager::install("limma")
BiocManager::install("edgeR")

BiocManager::install("GEOquery")
BiocManager::install("oligo")
BiocManager::install("pd.mogene.2.1.st")
BiocManager::install("RSQLite")
BiocManager::install("pvca")
BiocManager::install("mogene21sttranscriptcluster.db")
BiocManager::install("magrittr")
BiocManager::install("clusterProfiler")
BiocManager::install("rWikiPathways", update = FALSE)
```

# Abstract

# Objetivos

# Materiales y métodos

## Los Datos

Los datos proporcionados en el enunciado provienen del repositorio GTEx (*Genotype-Tissue Expression*), que recoge información de expresión específica de 54 tipos de tejido sano, proveniente de 1000 individuos [@GTEx]. Este [**portal**](https://www.gtexportal.org/home/) permite el acceso a los datos de expresión, imágenes de histología, etc. 

Obtenemos los datos de targets y counts de los archivos csv proporcionados en el enunciado: `r params$file1` y `r params$file2`. 

```{r unzip and load data, include=FALSE}
library(utils)
unzip("archivos_targets_y_counts.zip", overwrite = FALSE, exdir = params$folder.data)

all_targets <- read.csv(file = file.path(params$folder.data, params$file1))

all_counts <- read.csv2(file = file.path(params$folder.data, params$file2), header = TRUE)
```

Estos son datos de expresión (RNA-seq) pertenecientes a un análisis del tiroides, donde se comparan tres tipos de infiltración en `r nrow(all_targets)` muestras:

  - *Not infiltrated tissues* (**NIT**): `r nrow(subset(all_targets, Group == "NIT"))` muestras
  - *Small focal infiltrates* (**SFI**): `r nrow(subset(all_targets, Group == "SFI"))` muestras
  - *Extensive lymphoid infiltrates* (**ELI**): `r nrow(subset(all_targets, Group == "ELI"))` muestras
  
Con este script extraemos 10 muestras de cada grupo del archivo `r params$file1` y subseteamos las columnas escogidas en el archivo `r params$file2`:

```{r extraer los datos}
#Separamos el dataframe que recoge los targets por grupos
NIT <- subset(all_targets, Group == "NIT")
SFI <- subset(all_targets, Group == "SFI")
ELI <- subset(all_targets, Group == "ELI")

#Seleccionamos 10 muestras de cada grupo y las unimos en un único dataframe que recoge los targets con los que trabajaremos
set.seed(params$seed.extract)
NIT10 <- NIT[sample(nrow(NIT), size = 10, replace = FALSE),]
SFI10 <- SFI[sample(nrow(SFI), size = 10, replace = FALSE),]
ELI10 <- ELI[sample(nrow(ELI), size = 10, replace = FALSE),]

mytargets <- rbind(NIT10, SFI10, ELI10, deparse.level = 0)

#Extraemos los nombres de las muestras y cambiamos los guiones por puntos para que coincidan con los nombres de las muestras en el dataframe de counts
sample_names <- mytargets[,3]
s_names <- gsub("-", ".", sample_names)

#Subseteamos las columans escogidas del dataframe de counts
mycounts <- dplyr::select(all_counts, s_names)
row.names(mycounts) <- all_counts$X
```

De este modo hemos obtenido dos datasets: `mytargets` que recoge los detalles de cada una de las `r nrow(mytargets)` muestras con las que vamos a trabajar, y `mycounts`, que representa la tabla de contajes de estas `r ncol(mycounts)` muestras.

## Preprocesado de los datos

Para poder identificar los tipos de muestra con mayor facilidad, procedemos a renombrar las columnas de `mycounts` con nombres cortos indicativos de a qué grupo pertenecen, y también lo asignamos a `mytargets`. 

```{r renombrar columnas}

newShortNames <- c(paste0("NIT", 1:10), paste0("SFI", 1:10), paste0("ELI", 1:10))
mytargets <- cbind(mytargets, newShortNames)

#Asignamos los nuevos nombres cortos a las columnas de mycounts
colnames(mycounts) <- mytargets$newShortNames
```

De este modo, nuestros datos de contaje quedan así: 

```{r mycounts head}
head(mycounts)
```

Antes de proceder con el análisis de los datos, debemos evaluar la calidad de los datos crudos con los que vamos a trabajar, para detectar cualquier fallo técnico que pueda afectar a la interpretación de los datos. Analizaremos la calidad de los datos con representaciones gráficas, y dado que los datos resultantes de contajes suelen estar altamente sesgados, aplicaremos previamente una transformación logarítmica en base 2 para "normalizar" los datos. Además hemos de tener en cuenta que algunos de los contajes resultan en 0, para que ello no suponga un problema tomaremos *pseudocounts*, sumando una constante en todos los contajes, para que no den problema en la transformación logarítmica. 

```{r visual log2 pseudocounts}
pseudoCounts <- log2(mycounts +1)

library(ggplot2)

ggplot(pseudoCounts, aes(x= pseudoCounts[,1])) + ylab(expression(log[2](count +1))) + xlab(names(pseudoCounts)[1]) + geom_histogram(colour = "white", fill = "#525252", binwidth = 0.6)
```

Esta transformación logarítmica podría no ser suficiente para evaluar realmente cómo se distribuyen los datos, ya que los datos procedentes de RNA-seq no son homocedásticos, sino que su varianza aumenta según aumenta la media. Intentamos utilizar una función especializada del paquete `edgeR` para hacer una transformación de los datos y comparamos los resultados: 

```{r cpm pseudocount}
library(edgeR)
pseudoCounts2 <- cpm(mycounts, prior.count = 2, log = TRUE)

library(ggplot2)
ggplot(pseudoCounts, aes(x= pseudoCounts2[,1])) + ylab("CPM") + xlab(names(mycounts)[1]) + geom_histogram(colour = "white", fill = "#525252", binwidth = 0.6)
```

Para poder visualizar la distribución de los datos de las 30 muestras con las que trabajamos, las representamos en forma de boxplot: 

```{r boxplot rawdata pseudocounts, echo=FALSE}
boxplot(pseudoCounts, which = "all", las=2,
        col = c(rep("yellow1",10), rep("olivedrab1",10),
                rep("skyblue1",10)),
        main = "Distribución de contajes de pseudoCounts")
```
```{r boxplot rawdata pseudocounts2, echo=FALSE}
boxplot(pseudoCounts2, which = "all", las=2,
        col = c(rep("yellow1",10), rep("olivedrab1",10),
                rep("skyblue1",10)),
        main = "Distribución de contajes de pseudoCounts2 (con edgeR)")
```

Representamos los datos en gráficos de densidades para detectar si pudiera haber modos secundarios de la distribución de los datos:

```{r density plot, echo=FALSE, fig.cap="Gráficos de densidades que muestra las densidades empíricas de las muestras individuales dentro de cada una de las tres condiciones experimentales"}
pseudoCount_df = reshape2::melt(pseudoCounts, variable.name = "Samples")
pseudoCount_df = data.frame(pseudoCount_df, Condition = substr(pseudoCount_df$Samples, 1, 3))

ggplot(pseudoCount_df, aes(x=value, colour = Samples, fill = Samples)) + ylim(c(0, 0.25)) + geom_density(alpha = 0.2, size = 1.25) + facet_wrap(~ Condition) + theme(legend.position = "top") + xlab(expression(log[2](count + 1)))
```

Para comprobar la reproducibilidad de las muestras, representamos los MA-plots para comparar muestras entre sí:

```{r myMAplot}
myMAplot <- function(dataset, numberX, numberY){
  data <- dataset
  
  nameX <- names(data)[numberX]
  nameY <- names(data)[numberY]
  
  x <- data[,numberX]
  y <- data[,numberY]
  
  M = x - y
  A = (x+y)/2
  
  dfMA <- data.frame(A,M)
  
  library(ggplot2)
  ggplot(dfMA, aes(x=A, y=M)) + geom_point(size = 1.5, alpha = 1/5)  + stat_smooth(se = F, method = "loess", color = "red3") + ggtitle(paste(nameX, " vs ", nameY))
}
```

```{r myMAplot group 1, include=FALSE}
library(cowplot)

MA_NIT_1_2 <- myMAplot(pseudoCounts, 1, 2)
MA_NIT_3_4 <- myMAplot(pseudoCounts, 3, 4)
MA_NIT_5_6 <- myMAplot(pseudoCounts, 5, 6)

MA_SFI_11_12 <- myMAplot(pseudoCounts, 11, 12)
MA_SFI_15_16 <- myMAplot(pseudoCounts, 15, 16)
MA_SFI_18_19 <- myMAplot(pseudoCounts, 18, 19)

MA_ELI_21_22 <- myMAplot(pseudoCounts, 21, 22)
MA_ELI_23_25 <- myMAplot(pseudoCounts, 23, 25)
MA_ELI_26_28 <- myMAplot(pseudoCounts, 26, 28)
```             

```{r MAplot NIT, echo=FALSE, fig.cap="Representación MA de tres comparaciones entre muestras del grupo NIT", fig.height= 3}
plot_grid(MA_NIT_1_2, MA_NIT_3_4, MA_NIT_5_6, align = "h", nrow = 1, ncol = 3)
```

```{r MAplot SFI, echo=FALSE, fig.cap="Representación MA de tres comparaciones entre muestras del grupo SFI",  fig.height= 3}
plot_grid(MA_SFI_10_11, MA_SFI_15_16, MA_SFI_18_19, align = "h", nrow = 1, ncol = 3)
```

```{r MAplot ELI, echo=FALSE, fig.cap="Representación MA de tres comparaciones entre muestras del grupo ELI",  fig.height= 3}
plot_grid(MA_ELI_20_22, MA_ELI_23_25, MA_ELI_26_28, align = "h", nrow = 1, ncol = 3)
```


### Filtraje

### Normalización

## Identificación de genes diferencialmente expresados

## Anotación de los resultados

## Busca de patrones de expresión y agrupación de las muestras (comparación entre las distintas comparaciones)

## Análisis de significación biológica ("*Gene Enrichment Analysis*")

# Resultados 

# Discusión

# Apéndice

# Bibliografía
